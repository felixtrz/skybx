"use strict";
(self["webpackChunkskybx"] = self["webpackChunkskybx"] || []).push([["vendors-node_modules_elixr_node_modules_dimforge_rapier3d_rapier_js"],{

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/coarena.js":
/*!***********************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/coarena.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Coarena": () => (/* binding */ Coarena)
/* harmony export */ });
class Coarena {
    constructor() {
        this.fconv = new Float64Array(1);
        this.uconv = new Uint32Array(this.fconv.buffer);
        this.data = new Array();
        this.size = 0;
    }
    set(handle, data) {
        let i = this.index(handle);
        while (this.data.length <= i) {
            this.data.push(null);
        }
        if (this.data[i] == null)
            this.size += 1;
        this.data[i] = data;
    }
    len() {
        return this.size;
    }
    delete(handle) {
        let i = this.index(handle);
        if (i < this.data.length) {
            if (this.data[i] != null)
                this.size -= 1;
            this.data[i] = null;
        }
    }
    clear() {
        this.data = new Array();
    }
    get(handle) {
        let i = this.index(handle);
        if (i < this.data.length) {
            return this.data[i];
        }
        else {
            return null;
        }
    }
    forEach(f) {
        for (const elt of this.data) {
            if (elt != null)
                f(elt);
        }
    }
    getAll() {
        return this.data.filter((elt) => elt != null);
    }
    index(handle) {
        /// Extracts the index part of a handle (the lower 32 bits).
        /// This is done by first injecting the handle into an Float64Array
        /// which is itself injected into an Uint32Array (at construction time).
        /// The 0-th value of the Uint32Array will become the `number` integer
        /// representation of the lower 32 bits.
        /// Also `this.uconv[1]` then contains the generation number as a `number`,
        /// which we don’t really need.
        this.fconv[0] = handle;
        return this.uconv[0];
    }
}
//# sourceMappingURL=coarena.js.map

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/control/character_controller.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/control/character_controller.js ***!
  \********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharacterCollision": () => (/* binding */ CharacterCollision),
/* harmony export */   "KinematicCharacterController": () => (/* binding */ KinematicCharacterController)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);


/**
 * A collision between the character and an obstacle hit on its path.
 */
class CharacterCollision {
}
/**
 * A character controller for controlling kinematic bodies and parentless colliders by hitting
 * and sliding against obstacles.
 */
class KinematicCharacterController {
    constructor(offset, params, bodies, colliders, queries) {
        this.params = params;
        this.bodies = bodies;
        this.colliders = colliders;
        this.queries = queries;
        this.raw = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController(offset);
        this.rawCharacterCollision = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision();
        this._applyImpulsesToDynamicBodies = false;
        this._characterMass = null;
    }
    /** @internal */
    free() {
        if (!!this.raw) {
            this.raw.free();
            this.rawCharacterCollision.free();
        }
        this.raw = undefined;
        this.rawCharacterCollision = undefined;
    }
    /**
     * The direction that goes "up". Used to determine where the floor is, and the floor’s angle.
     */
    up() {
        return this.raw.up();
    }
    /**
     * Sets the direction that goes "up". Used to determine where the floor is, and the floor’s angle.
     */
    setUp(vector) {
        let rawVect = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(vector);
        return this.raw.setUp(rawVect);
        rawVect.free();
    }
    applyImpulsesToDynamicBodies() {
        return this._applyImpulsesToDynamicBodies;
    }
    setApplyImpulsesToDynamicBodies(enabled) {
        this._applyImpulsesToDynamicBodies = enabled;
    }
    /**
     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.
     */
    characterMass() {
        return this._characterMass;
    }
    /**
     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`
     * is set to `true`.
     *
     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal
     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider
     * isn’t attached to any rigid-body.
     *
     * @param mass - The mass to set.
     */
    setCharacterMass(mass) {
        this._characterMass = mass;
    }
    /**
     * A small gap to preserve between the character and its surroundings.
     *
     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small
     * (must not be zero) to improve numerical stability of the character controller.
     */
    offset() {
        return this.raw.offset();
    }
    /**
     * Sets a small gap to preserve between the character and its surroundings.
     *
     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small
     * (must not be zero) to improve numerical stability of the character controller.
     */
    setOffset(value) {
        this.raw.setOffset(value);
    }
    /**
     * Is sliding against obstacles enabled?
     */
    slideEnabled() {
        return this.raw.slideEnabled();
    }
    /**
     * Enable or disable sliding against obstacles.
     */
    setSlideEnabled(enabled) {
        this.raw.setSlideEnabled(enabled);
    }
    /**
     * The maximum step height a character can automatically step over.
     */
    autostepMaxHeight() {
        return this.raw.autostepMaxHeight();
    }
    /**
     * The minimum width of free space that must be available after stepping on a stair.
     */
    autostepMinWidth() {
        return this.raw.autostepMinWidth();
    }
    /**
     * Can the character automatically step over dynamic bodies too?
     */
    autostepIncludesDynamicBodies() {
        return this.raw.autostepIncludesDynamicBodies();
    }
    /**
     * Is automatically stepping over small objects enabled?
     */
    autostepEnabled() {
        return this.raw.autostepEnabled();
    }
    /**
     * Enabled automatically stepping over small objects.
     *
     * @param maxHeight - The maximum step height a character can automatically step over.
     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.
     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?
     */
    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {
        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);
    }
    /**
     * Disable automatically stepping over small objects.
     */
    disableAutostep() {
        return this.raw.disableAutostep();
    }
    /**
     * The maximum angle (radians) between the floor’s normal and the `up` vector that the
     * character is able to climb.
     */
    maxSlopeClimbAngle() {
        return this.raw.maxSlopeClimbAngle();
    }
    /**
     * Sets the maximum angle (radians) between the floor’s normal and the `up` vector that the
     * character is able to climb.
     */
    setMaxSlopeClimbAngle(angle) {
        this.raw.setMaxSlopeClimbAngle(angle);
    }
    /**
     * The minimum angle (radians) between the floor’s normal and the `up` vector before the
     * character starts to slide down automatically.
     */
    minSlopeSlideAngle() {
        return this.raw.minSlopeSlideAngle();
    }
    /**
     * Sets the minimum angle (radians) between the floor’s normal and the `up` vector before the
     * character starts to slide down automatically.
     */
    setMinSlopeSlideAngle(angle) {
        this.raw.setMinSlopeSlideAngle(angle);
    }
    /**
     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if
     * the distance between the ground and its feet are smaller than the specified threshold?
     */
    snapToGroundDistance() {
        return this.raw.snapToGroundDistance();
    }
    /**
     * Enables automatically snapping the character to the ground if the distance between
     * the ground and its feet are smaller than the specified threshold.
     */
    enableSnapToGround(distance) {
        this.raw.enableSnapToGround(distance);
    }
    /**
     * Disables automatically snapping the character to the ground.
     */
    disableSnapToGround() {
        this.raw.disableSnapToGround();
    }
    /**
     * Is automatically snapping the character to the ground enabled?
     */
    snapToGroundEnabled() {
        return this.raw.snapToGroundEnabled();
    }
    /**
     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.
     *
     * @param collider - The collider to move.
     * @param desiredTranslation - The desired collider movement.
     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.
     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles
     *                       taken into account.
     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the
     *                          obstacles taken into account.
     */
    computeColliderMovement(collider, desiredTranslation, filterFlags, filterGroups, filterPredicate) {
        let rawTranslation = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(desiredTranslation);
        this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslation, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));
        rawTranslation.free();
    }
    /**
     * The movement computed by the last call to `this.computeColliderMovement`.
     */
    computedMovement() {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.computedMovement());
    }
    /**
     * The result of ground detection computed by the last call to `this.computeColliderMovement`.
     */
    computedGrounded() {
        return this.raw.computedGrounded();
    }
    /**
     * The number of collisions against obstacles detected along the path of the last call
     * to `this.computeColliderMovement`.
     */
    numComputedCollisions() {
        return this.raw.numComputedCollisions();
    }
    /**
     * Returns the collision against one of the obstacles detected along the path of the last
     * call to `this.computeColliderMovement`.
     *
     * @param i - The i-th collision will be returned.
     * @param out - If this argument is set, it will be filled with the collision information.
     */
    computedCollision(i, out) {
        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {
            return null;
        }
        else {
            let c = this.rawCharacterCollision;
            out = out !== null && out !== void 0 ? out : new CharacterCollision();
            out.translationApplied = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationApplied());
            out.translationRemaining = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationRemaining());
            out.toi = c.toi();
            out.witness1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness1());
            out.witness2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness2());
            out.normal1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal1());
            out.normal2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal2());
            out.collider = this.colliders.get(c.handle());
            return out;
        }
    }
}
//# sourceMappingURL=character_controller.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/control/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/control/index.js ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharacterCollision": () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),
/* harmony export */   "KinematicCharacterController": () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController)
/* harmony export */ });
/* harmony import */ var _character_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character_controller */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/control/character_controller.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_character_controller__WEBPACK_IMPORTED_MODULE_0__]);
_character_controller__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

//# sourceMappingURL=index.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js ***!
  \***********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CCDSolver": () => (/* binding */ CCDSolver)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);
_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

/**
 * The CCD solver responsible for resolving Continuous Collision Detection.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`
 * once you are done using it.
 */
class CCDSolver {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver();
    }
    /**
     * Release the WASM memory occupied by this narrow-phase.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
}
//# sourceMappingURL=ccd_solver.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js ***!
  \**************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FixedImpulseJoint": () => (/* binding */ FixedImpulseJoint),
/* harmony export */   "ImpulseJoint": () => (/* binding */ ImpulseJoint),
/* harmony export */   "JointData": () => (/* binding */ JointData),
/* harmony export */   "JointType": () => (/* binding */ JointType),
/* harmony export */   "MotorModel": () => (/* binding */ MotorModel),
/* harmony export */   "PrismaticImpulseJoint": () => (/* binding */ PrismaticImpulseJoint),
/* harmony export */   "RevoluteImpulseJoint": () => (/* binding */ RevoluteImpulseJoint),
/* harmony export */   "SphericalImpulseJoint": () => (/* binding */ SphericalImpulseJoint),
/* harmony export */   "UnitImpulseJoint": () => (/* binding */ UnitImpulseJoint)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__]);
([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);


/**
 * An enum grouping all possible types of joints:
 *
 * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected
 *               bodies except for the rotation along one axis.
 * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.
 * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected
 *                bodies except for the translation along one axis.
 * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.
 */
var JointType;
(function (JointType) {
    JointType[JointType["Revolute"] = 0] = "Revolute";
    JointType[JointType["Fixed"] = 1] = "Fixed";
    JointType[JointType["Prismatic"] = 2] = "Prismatic";
    // #if DIM3
    JointType[JointType["Spherical"] = 3] = "Spherical";
    // #endif
})(JointType || (JointType = {}));
var MotorModel;
(function (MotorModel) {
    MotorModel[MotorModel["AccelerationBased"] = 0] = "AccelerationBased";
    MotorModel[MotorModel["ForceBased"] = 1] = "ForceBased";
})(MotorModel || (MotorModel = {}));
class ImpulseJoint {
    constructor(rawSet, bodySet, handle) {
        this.rawSet = rawSet;
        this.bodySet = bodySet;
        this.handle = handle;
    }
    static newTyped(rawSet, bodySet, handle) {
        switch (rawSet.jointType(handle)) {
            case JointType.Revolute:
                return new RevoluteImpulseJoint(rawSet, bodySet, handle);
            case JointType.Prismatic:
                return new PrismaticImpulseJoint(rawSet, bodySet, handle);
            case JointType.Fixed:
                return new FixedImpulseJoint(rawSet, bodySet, handle);
            // #if DIM3
            case JointType.Spherical:
                return new SphericalImpulseJoint(rawSet, bodySet, handle);
            // #endif
            default:
                return new ImpulseJoint(rawSet, bodySet, handle);
        }
    }
    /** @internal */
    finalizeDeserialization(bodySet) {
        this.bodySet = bodySet;
    }
    /**
     * Checks if this joint is still valid (i.e. that it has
     * not been deleted from the joint set yet).
     */
    isValid() {
        return this.rawSet.contains(this.handle);
    }
    /**
     * The first rigid-body this joint it attached to.
     */
    body1() {
        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));
    }
    /**
     * The second rigid-body this joint is attached to.
     */
    body2() {
        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));
    }
    /**
     * The type of this joint given as a string.
     */
    type() {
        return this.rawSet.jointType(this.handle);
    }
    // #if DIM3
    /**
     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.
     */
    frameX1() {
        return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));
    }
    // #endif
    // #if DIM3
    /**
     * The rotation matrix that aligns this joint's second local axis to the `x` axis.
     */
    frameX2() {
        return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));
    }
    // #endif
    /**
     * The position of the first anchor of this joint.
     *
     * The first anchor gives the position of the application point on the
     * local frame of the first rigid-body it is attached to.
     */
    anchor1() {
        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));
    }
    /**
     * The position of the second anchor of this joint.
     *
     * The second anchor gives the position of the application point on the
     * local frame of the second rigid-body it is attached to.
     */
    anchor2() {
        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));
    }
    /**
     * Sets the position of the first anchor of this joint.
     *
     * The first anchor gives the position of the application point on the
     * local frame of the first rigid-body it is attached to.
     */
    setAnchor1(newPos) {
        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(newPos);
        this.rawSet.jointSetAnchor1(this.handle, rawPoint);
        rawPoint.free();
    }
    /**
     * Sets the position of the second anchor of this joint.
     *
     * The second anchor gives the position of the application point on the
     * local frame of the second rigid-body it is attached to.
     */
    setAnchor2(newPos) {
        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(newPos);
        this.rawSet.jointSetAnchor2(this.handle, rawPoint);
        rawPoint.free();
    }
    /**
     * Controls whether contacts are computed between colliders attached
     * to the rigid-bodies linked by this joint.
     */
    setContactsEnabled(enabled) {
        this.rawSet.jointSetContactsEnabled(this.handle, enabled);
    }
    /**
     * Indicates if contacts are enabled between colliders attached
     * to the rigid-bodies linked by this joint.
     */
    contactsEnabled() {
        return this.rawSet.jointContactsEnabled(this.handle);
    }
}
class UnitImpulseJoint extends ImpulseJoint {
    /**
     * Are the limits enabled for this joint?
     */
    limitsEnabled() {
        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());
    }
    /**
     * The min limit of this joint.
     */
    limitsMin() {
        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());
    }
    /**
     * The max limit of this joint.
     */
    limitsMax() {
        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());
    }
    /**
     * Sets the limits of this joint.
     *
     * @param min - The minimum bound of this joint’s free coordinate.
     * @param max - The maximum bound of this joint’s free coordinate.
     */
    setLimits(min, max) {
        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);
    }
    configureMotorModel(model) {
        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);
    }
    configureMotorVelocity(targetVel, factor) {
        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);
    }
    configureMotorPosition(targetPos, stiffness, damping) {
        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);
    }
    configureMotor(targetPos, targetVel, stiffness, damping) {
        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);
    }
}
class FixedImpulseJoint extends ImpulseJoint {
}
class PrismaticImpulseJoint extends UnitImpulseJoint {
    rawAxis() {
        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.X;
    }
}
class RevoluteImpulseJoint extends UnitImpulseJoint {
    rawAxis() {
        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.AngX;
    }
}
// #if DIM3
class SphericalImpulseJoint extends ImpulseJoint {
}
// #endif
class JointData {
    constructor() { }
    /**
     * Creates a new joint descriptor that builds a Fixed joint.
     *
     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their
     * anchor and local frames coincide in world-space.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.
     */
    static fixed(anchor1, frame1, anchor2, frame2) {
        let res = new JointData();
        res.anchor1 = anchor1;
        res.anchor2 = anchor2;
        res.frame1 = frame1;
        res.frame2 = frame2;
        res.jointType = JointType.Fixed;
        return res;
    }
    // #if DIM3
    /**
     * Create a new joint descriptor that builds spherical joints.
     *
     * A spherical joint allows three relative rotational degrees of freedom
     * by preventing any relative translation between the anchors of the
     * two attached rigid-bodies.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     */
    static spherical(anchor1, anchor2) {
        let res = new JointData();
        res.anchor1 = anchor1;
        res.anchor2 = anchor2;
        res.jointType = JointType.Spherical;
        return res;
    }
    /**
     * Creates a new joint descriptor that builds a Prismatic joint.
     *
     * A prismatic joint removes all the degrees of freedom between the
     * affected bodies, except for the translation along one axis.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.
     */
    static prismatic(anchor1, anchor2, axis) {
        let res = new JointData();
        res.anchor1 = anchor1;
        res.anchor2 = anchor2;
        res.axis = axis;
        res.jointType = JointType.Prismatic;
        return res;
    }
    /**
     * Create a new joint descriptor that builds Revolute joints.
     *
     * A revolute joint removes all degrees of freedom between the affected
     * bodies except for the rotation along one axis.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.
     */
    static revolute(anchor1, anchor2, axis) {
        let res = new JointData();
        res.anchor1 = anchor1;
        res.anchor2 = anchor2;
        res.axis = axis;
        res.jointType = JointType.Revolute;
        return res;
    }
    // #endif
    intoRaw() {
        let rawA1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.anchor1);
        let rawA2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.anchor2);
        let rawAx;
        let result;
        let limitsEnabled = false;
        let limitsMin = 0.0;
        let limitsMax = 0.0;
        switch (this.jointType) {
            case JointType.Fixed:
                let rawFra1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(this.frame1);
                let rawFra2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(this.frame2);
                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);
                rawFra1.free();
                rawFra2.free();
                break;
            case JointType.Prismatic:
                rawAx = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.axis);
                if (!!this.limitsEnabled) {
                    limitsEnabled = true;
                    limitsMin = this.limits[0];
                    limitsMax = this.limits[1];
                }
                // #if DIM3
                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);
                // #endif
                rawAx.free();
                break;
            // #if DIM3
            case JointType.Spherical:
                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.spherical(rawA1, rawA2);
                break;
            case JointType.Revolute:
                rawAx = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.axis);
                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.revolute(rawA1, rawA2, rawAx);
                rawAx.free();
                break;
            // #endif
        }
        rawA1.free();
        rawA2.free();
        return result;
    }
}
//# sourceMappingURL=impulse_joint.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImpulseJointSet": () => (/* binding */ ImpulseJointSet)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/coarena.js");
/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impulse_joint */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



/**
 * A set of joints.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`
 * once you are done using it (and all the joints it created).
 */
class ImpulseJointSet {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet();
        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();
        // Initialize the map with the existing elements, if any.
        if (raw) {
            raw.forEachJointHandle((handle) => {
                this.map.set(handle, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(raw, null, handle));
            });
        }
    }
    /**
     * Release the WASM memory occupied by this joint set.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
        if (!!this.map) {
            this.map.clear();
        }
        this.map = undefined;
    }
    /** @internal */
    finalizeDeserialization(bodies) {
        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));
    }
    /**
     * Creates a new joint and return its integer handle.
     *
     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.
     * @param desc - The joint's parameters.
     * @param parent1 - The handle of the first rigid-body this joint is attached to.
     * @param parent2 - The handle of the second rigid-body this joint is attached to.
     * @param wakeUp - Should the attached rigid-bodies be awakened?
     */
    createJoint(bodies, desc, parent1, parent2, wakeUp) {
        const rawParams = desc.intoRaw();
        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);
        rawParams.free();
        let joint = _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(this.raw, bodies, handle);
        this.map.set(handle, joint);
        return joint;
    }
    /**
     * Remove a joint from this set.
     *
     * @param handle - The integer handle of the joint.
     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.
     */
    remove(handle, wakeUp) {
        this.raw.remove(handle, wakeUp);
        this.unmap(handle);
    }
    /**
     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.
     *
     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.
     */
    forEachJointHandleAttachedToRigidBody(handle, f) {
        this.raw.forEachJointAttachedToRigidBody(handle, f);
    }
    /**
     * Internal function, do not call directly.
     * @param handle
     */
    unmap(handle) {
        this.map.delete(handle);
    }
    /**
     * The number of joints on this set.
     */
    len() {
        return this.map.len();
    }
    /**
     * Does this set contain a joint with the given handle?
     *
     * @param handle - The joint handle to check.
     */
    contains(handle) {
        return this.get(handle) != null;
    }
    /**
     * Gets the joint with the given handle.
     *
     * Returns `null` if no joint with the specified handle exists.
     *
     * @param handle - The integer handle of the joint to retrieve.
     */
    get(handle) {
        return this.map.get(handle);
    }
    /**
     * Applies the given closure to each joint contained by this set.
     *
     * @param f - The closure to apply.
     */
    forEach(f) {
        this.map.forEach(f);
    }
    /**
     * Gets all joints in the list.
     *
     * @returns joint list.
     */
    getAll() {
        return this.map.getAll();
    }
}
//# sourceMappingURL=impulse_joint_set.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/index.js ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CCDSolver": () => (/* reexport safe */ _ccd_solver__WEBPACK_IMPORTED_MODULE_8__.CCDSolver),
/* harmony export */   "CoefficientCombineRule": () => (/* reexport safe */ _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__.CoefficientCombineRule),
/* harmony export */   "FixedImpulseJoint": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.FixedImpulseJoint),
/* harmony export */   "FixedMultibodyJoint": () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.FixedMultibodyJoint),
/* harmony export */   "ImpulseJoint": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.ImpulseJoint),
/* harmony export */   "ImpulseJointSet": () => (/* reexport safe */ _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__.ImpulseJointSet),
/* harmony export */   "IntegrationParameters": () => (/* reexport safe */ _integration_parameters__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),
/* harmony export */   "IslandManager": () => (/* reexport safe */ _island_manager__WEBPACK_IMPORTED_MODULE_9__.IslandManager),
/* harmony export */   "JointData": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointData),
/* harmony export */   "JointType": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointType),
/* harmony export */   "MotorModel": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.MotorModel),
/* harmony export */   "MultibodyJoint": () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.MultibodyJoint),
/* harmony export */   "MultibodyJointSet": () => (/* reexport safe */ _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__.MultibodyJointSet),
/* harmony export */   "PrismaticImpulseJoint": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.PrismaticImpulseJoint),
/* harmony export */   "PrismaticMultibodyJoint": () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.PrismaticMultibodyJoint),
/* harmony export */   "RevoluteImpulseJoint": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.RevoluteImpulseJoint),
/* harmony export */   "RevoluteMultibodyJoint": () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.RevoluteMultibodyJoint),
/* harmony export */   "RigidBody": () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBody),
/* harmony export */   "RigidBodyDesc": () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),
/* harmony export */   "RigidBodySet": () => (/* reexport safe */ _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__.RigidBodySet),
/* harmony export */   "RigidBodyType": () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),
/* harmony export */   "SphericalImpulseJoint": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.SphericalImpulseJoint),
/* harmony export */   "SphericalMultibodyJoint": () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.SphericalMultibodyJoint),
/* harmony export */   "UnitImpulseJoint": () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.UnitImpulseJoint),
/* harmony export */   "UnitMultibodyJoint": () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.UnitMultibodyJoint)
/* harmony export */ });
/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rigid_body */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/rigid_body.js");
/* harmony import */ var _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rigid_body_set */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js");
/* harmony import */ var _integration_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./integration_parameters */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js");
/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impulse_joint */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js");
/* harmony import */ var _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impulse_joint_set */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js");
/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multibody_joint */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js");
/* harmony import */ var _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./multibody_joint_set */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js");
/* harmony import */ var _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coefficient_combine_rule */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/coefficient_combine_rule.js");
/* harmony import */ var _ccd_solver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ccd_solver */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js");
/* harmony import */ var _island_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./island_manager */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/island_manager.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__]);
([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);










//# sourceMappingURL=index.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js ***!
  \***********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IntegrationParameters": () => (/* binding */ IntegrationParameters)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);
_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

class IntegrationParameters {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters();
    }
    /**
     * Free the WASM memory used by these integration parameters.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    /**
     * The timestep length (default: `1.0 / 60.0`)
     */
    get dt() {
        return this.raw.dt;
    }
    /**
     * The Error Reduction Parameter in `[0, 1]` is the proportion of
     * the positional error to be corrected at each time step (default: `0.2`).
     */
    get erp() {
        return this.raw.erp;
    }
    /**
     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).
     */
    get allowedLinearError() {
        return this.raw.allowedLinearError;
    }
    /**
     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).
     */
    get predictionDistance() {
        return this.raw.predictionDistance;
    }
    /**
     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).
     */
    get maxVelocityIterations() {
        return this.raw.maxVelocityIterations;
    }
    /**
     * Maximum number of friction iterations performed by the position-based constraints solver (default: `1`).
     */
    get maxVelocityFrictionIterations() {
        return this.raw.maxVelocityFrictionIterations;
    }
    /**
     * Maximum number of stabilization iterations performed by the position-based constraints solver (default: `1`).
     */
    get maxStabilizationIterations() {
        return this.raw.maxStabilizationIterations;
    }
    /**
     * Minimum number of dynamic bodies in each active island (default: `128`).
     */
    get minIslandSize() {
        return this.raw.minIslandSize;
    }
    /**
     * Maximum number of substeps performed by the  solver (default: `1`).
     */
    get maxCcdSubsteps() {
        return this.raw.maxCcdSubsteps;
    }
    set dt(value) {
        this.raw.dt = value;
    }
    set erp(value) {
        this.raw.erp = value;
    }
    set allowedLinearError(value) {
        this.raw.allowedLinearError = value;
    }
    set predictionDistance(value) {
        this.raw.predictionDistance = value;
    }
    set maxVelocityIterations(value) {
        this.raw.maxVelocityIterations = value;
    }
    set maxVelocityFrictionIterations(value) {
        this.raw.maxVelocityFrictionIterations = value;
    }
    set maxStabilizationIterations(value) {
        this.raw.maxStabilizationIterations = value;
    }
    set minIslandSize(value) {
        this.raw.minIslandSize = value;
    }
    set maxCcdSubsteps(value) {
        this.raw.maxCcdSubsteps = value;
    }
}
//# sourceMappingURL=integration_parameters.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/island_manager.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/island_manager.js ***!
  \***************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IslandManager": () => (/* binding */ IslandManager)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);
_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

/**
 * The CCD solver responsible for resolving Continuous Collision Detection.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`
 * once you are done using it.
 */
class IslandManager {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager();
    }
    /**
     * Release the WASM memory occupied by this narrow-phase.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    /**
     * Applies the given closure to the handle of each active rigid-bodies contained by this set.
     *
     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.
     *
     * @param f - The closure to apply.
     */
    forEachActiveRigidBodyHandle(f) {
        this.raw.forEachActiveRigidBodyHandle(f);
    }
}
//# sourceMappingURL=island_manager.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js ***!
  \****************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FixedMultibodyJoint": () => (/* binding */ FixedMultibodyJoint),
/* harmony export */   "MultibodyJoint": () => (/* binding */ MultibodyJoint),
/* harmony export */   "PrismaticMultibodyJoint": () => (/* binding */ PrismaticMultibodyJoint),
/* harmony export */   "RevoluteMultibodyJoint": () => (/* binding */ RevoluteMultibodyJoint),
/* harmony export */   "SphericalMultibodyJoint": () => (/* binding */ SphericalMultibodyJoint),
/* harmony export */   "UnitMultibodyJoint": () => (/* binding */ UnitMultibodyJoint)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./impulse_joint */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_impulse_joint__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__]);
([_impulse_joint__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);


class MultibodyJoint {
    constructor(rawSet, handle) {
        this.rawSet = rawSet;
        this.handle = handle;
    }
    static newTyped(rawSet, handle) {
        switch (rawSet.jointType(handle)) {
            case _impulse_joint__WEBPACK_IMPORTED_MODULE_0__.JointType.Revolute:
                return new RevoluteMultibodyJoint(rawSet, handle);
            case _impulse_joint__WEBPACK_IMPORTED_MODULE_0__.JointType.Prismatic:
                return new PrismaticMultibodyJoint(rawSet, handle);
            case _impulse_joint__WEBPACK_IMPORTED_MODULE_0__.JointType.Fixed:
                return new FixedMultibodyJoint(rawSet, handle);
            // #if DIM3
            case _impulse_joint__WEBPACK_IMPORTED_MODULE_0__.JointType.Spherical:
                return new SphericalMultibodyJoint(rawSet, handle);
            // #endif
            default:
                return new MultibodyJoint(rawSet, handle);
        }
    }
    /**
     * Checks if this joint is still valid (i.e. that it has
     * not been deleted from the joint set yet).
     */
    isValid() {
        return this.rawSet.contains(this.handle);
    }
    // /**
    //  * The unique integer identifier of the first rigid-body this joint it attached to.
    //  */
    // public bodyHandle1(): RigidBodyHandle {
    //     return this.rawSet.jointBodyHandle1(this.handle);
    // }
    //
    // /**
    //  * The unique integer identifier of the second rigid-body this joint is attached to.
    //  */
    // public bodyHandle2(): RigidBodyHandle {
    //     return this.rawSet.jointBodyHandle2(this.handle);
    // }
    //
    // /**
    //  * The type of this joint given as a string.
    //  */
    // public type(): JointType {
    //     return this.rawSet.jointType(this.handle);
    // }
    //
    // // #if DIM3
    // /**
    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.
    //  */
    // public frameX1(): Rotation {
    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));
    // }
    //
    // // #endif
    //
    // // #if DIM3
    // /**
    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.
    //  */
    // public frameX2(): Rotation {
    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));
    // }
    //
    // // #endif
    //
    // /**
    //  * The position of the first anchor of this joint.
    //  *
    //  * The first anchor gives the position of the points application point on the
    //  * local frame of the first rigid-body it is attached to.
    //  */
    // public anchor1(): Vector {
    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));
    // }
    //
    // /**
    //  * The position of the second anchor of this joint.
    //  *
    //  * The second anchor gives the position of the points application point on the
    //  * local frame of the second rigid-body it is attached to.
    //  */
    // public anchor2(): Vector {
    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));
    // }
    /**
     * Controls whether contacts are computed between colliders attached
     * to the rigid-bodies linked by this joint.
     */
    setContactsEnabled(enabled) {
        this.rawSet.jointSetContactsEnabled(this.handle, enabled);
    }
    /**
     * Indicates if contacts are enabled between colliders attached
     * to the rigid-bodies linked by this joint.
     */
    contactsEnabled() {
        return this.rawSet.jointContactsEnabled(this.handle);
    }
}
class UnitMultibodyJoint extends MultibodyJoint {
}
class FixedMultibodyJoint extends MultibodyJoint {
}
class PrismaticMultibodyJoint extends UnitMultibodyJoint {
    rawAxis() {
        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.X;
    }
}
class RevoluteMultibodyJoint extends UnitMultibodyJoint {
    rawAxis() {
        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.AngX;
    }
}
// #if DIM3
class SphericalMultibodyJoint extends MultibodyJoint {
}
// #endif
//# sourceMappingURL=multibody_joint.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js ***!
  \********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultibodyJointSet": () => (/* binding */ MultibodyJointSet)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/coarena.js");
/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multibody_joint */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



/**
 * A set of joints.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`
 * once you are done using it (and all the joints it created).
 */
class MultibodyJointSet {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet();
        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();
        // Initialize the map with the existing elements, if any.
        if (raw) {
            raw.forEachJointHandle((handle) => {
                this.map.set(handle, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(this.raw, handle));
            });
        }
    }
    /**
     * Release the WASM memory occupied by this joint set.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
        if (!!this.map) {
            this.map.clear();
        }
        this.map = undefined;
    }
    /**
     * Creates a new joint and return its integer handle.
     *
     * @param desc - The joint's parameters.
     * @param parent1 - The handle of the first rigid-body this joint is attached to.
     * @param parent2 - The handle of the second rigid-body this joint is attached to.
     * @param wakeUp - Should the attached rigid-bodies be awakened?
     */
    createJoint(desc, parent1, parent2, wakeUp) {
        const rawParams = desc.intoRaw();
        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);
        rawParams.free();
        let joint = _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(this.raw, handle);
        this.map.set(handle, joint);
        return joint;
    }
    /**
     * Remove a joint from this set.
     *
     * @param handle - The integer handle of the joint.
     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.
     */
    remove(handle, wake_up) {
        this.raw.remove(handle, wake_up);
        this.map.delete(handle);
    }
    /**
     * Internal function, do not call directly.
     * @param handle
     */
    unmap(handle) {
        this.map.delete(handle);
    }
    /**
     * The number of joints on this set.
     */
    len() {
        return this.map.len();
    }
    /**
     * Does this set contain a joint with the given handle?
     *
     * @param handle - The joint handle to check.
     */
    contains(handle) {
        return this.get(handle) != null;
    }
    /**
     * Gets the joint with the given handle.
     *
     * Returns `null` if no joint with the specified handle exists.
     *
     * @param handle - The integer handle of the joint to retrieve.
     */
    get(handle) {
        return this.map.get(handle);
    }
    /**
     * Applies the given closure to each joint contained by this set.
     *
     * @param f - The closure to apply.
     */
    forEach(f) {
        this.map.forEach(f);
    }
    /**
     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.
     *
     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.
     */
    forEachJointHandleAttachedToRigidBody(handle, f) {
        this.raw.forEachJointAttachedToRigidBody(handle, f);
    }
    /**
     * Gets all joints in the list.
     *
     * @returns joint list.
     */
    getAll() {
        return this.map.getAll();
    }
}
//# sourceMappingURL=multibody_joint_set.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js ***!
  \***************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RigidBodySet": () => (/* binding */ RigidBodySet)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/coarena.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rigid_body */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/rigid_body.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _rigid_body__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _rigid_body__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);




/**
 * A set of rigid bodies that can be handled by a physics pipeline.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`
 * once you are done using it (and all the rigid-bodies it created).
 */
class RigidBodySet {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet();
        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();
        // deserialize
        if (raw) {
            raw.forEachRigidBodyHandle((handle) => {
                this.map.set(handle, new _rigid_body__WEBPACK_IMPORTED_MODULE_2__.RigidBody(raw, null, handle));
            });
        }
    }
    /**
     * Release the WASM memory occupied by this rigid-body set.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
        if (!!this.map) {
            this.map.clear();
        }
        this.map = undefined;
    }
    /**
     * Internal method, do not call this explicitly.
     */
    finalizeDeserialization(colliderSet) {
        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));
    }
    /**
     * Creates a new rigid-body and return its integer handle.
     *
     * @param desc - The description of the rigid-body to create.
     */
    createRigidBody(colliderSet, desc) {
        let rawTra = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.translation);
        let rawRot = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.rotation);
        let rawLv = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.linvel);
        let rawCom = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.centerOfMass);
        // #if DIM3
        let rawAv = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.angvel);
        let rawPrincipalInertia = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.principalAngularInertia);
        let rawInertiaFrame = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.angularInertiaLocalFrame);
        // #endif
        let handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv, 
        // #if DIM3
        rawAv, rawPrincipalInertia, rawInertiaFrame, desc.translationsEnabledX, desc.translationsEnabledY, desc.translationsEnabledZ, desc.rotationsEnabledX, desc.rotationsEnabledY, desc.rotationsEnabledZ, 
        // #endif
        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.ccdEnabled, desc.dominanceGroup);
        rawTra.free();
        rawRot.free();
        rawLv.free();
        rawCom.free();
        // #if DIM3
        rawAv.free();
        rawPrincipalInertia.free();
        rawInertiaFrame.free();
        // #endif
        const body = new _rigid_body__WEBPACK_IMPORTED_MODULE_2__.RigidBody(this.raw, colliderSet, handle);
        body.userData = desc.userData;
        this.map.set(handle, body);
        return body;
    }
    /**
     * Removes a rigid-body from this set.
     *
     * This will also remove all the colliders and joints attached to the rigid-body.
     *
     * @param handle - The integer handle of the rigid-body to remove.
     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.
     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.
     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.
     */
    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {
        // Unmap the entities that will be removed automatically because of the rigid-body removals.
        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {
            colliders.unmap(this.raw.rbCollider(handle, i));
        }
        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));
        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));
        // Remove the rigid-body.
        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);
        this.map.delete(handle);
    }
    /**
     * The number of rigid-bodies on this set.
     */
    len() {
        return this.map.len();
    }
    /**
     * Does this set contain a rigid-body with the given handle?
     *
     * @param handle - The rigid-body handle to check.
     */
    contains(handle) {
        return this.get(handle) != null;
    }
    /**
     * Gets the rigid-body with the given handle.
     *
     * @param handle - The handle of the rigid-body to retrieve.
     */
    get(handle) {
        return this.map.get(handle);
    }
    /**
     * Applies the given closure to each rigid-body contained by this set.
     *
     * @param f - The closure to apply.
     */
    forEach(f) {
        this.map.forEach(f);
    }
    /**
     * Applies the given closure to each active rigid-bodies contained by this set.
     *
     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.
     *
     * @param f - The closure to apply.
     */
    forEachActiveRigidBody(islands, f) {
        islands.forEachActiveRigidBodyHandle((handle) => {
            f(this.get(handle));
        });
    }
    /**
     * Gets all rigid-bodies in the list.
     *
     * @returns rigid-bodies list.
     */
    getAll() {
        return this.map.getAll();
    }
}
//# sourceMappingURL=rigid_body_set.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/exports.js":
/*!***********************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/exports.js ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveCollisionTypes": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),
/* harmony export */   "ActiveEvents": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveEvents),
/* harmony export */   "ActiveHooks": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),
/* harmony export */   "Ball": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ball),
/* harmony export */   "BroadPhase": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.BroadPhase),
/* harmony export */   "CCDSolver": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CCDSolver),
/* harmony export */   "Capsule": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Capsule),
/* harmony export */   "CharacterCollision": () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_5__.CharacterCollision),
/* harmony export */   "CoefficientCombineRule": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CoefficientCombineRule),
/* harmony export */   "Collider": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Collider),
/* harmony export */   "ColliderDesc": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),
/* harmony export */   "ColliderSet": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderSet),
/* harmony export */   "Cone": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Cone),
/* harmony export */   "ConvexPolyhedron": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ConvexPolyhedron),
/* harmony export */   "Cuboid": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Cuboid),
/* harmony export */   "Cylinder": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Cylinder),
/* harmony export */   "DebugRenderBuffers": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderBuffers),
/* harmony export */   "DebugRenderPipeline": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderPipeline),
/* harmony export */   "EventQueue": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.EventQueue),
/* harmony export */   "FeatureType": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.FeatureType),
/* harmony export */   "FixedImpulseJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedImpulseJoint),
/* harmony export */   "FixedMultibodyJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedMultibodyJoint),
/* harmony export */   "HalfSpace": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.HalfSpace),
/* harmony export */   "Heightfield": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Heightfield),
/* harmony export */   "ImpulseJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint),
/* harmony export */   "ImpulseJointSet": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJointSet),
/* harmony export */   "IntegrationParameters": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),
/* harmony export */   "IslandManager": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IslandManager),
/* harmony export */   "JointData": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointData),
/* harmony export */   "JointType": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointType),
/* harmony export */   "KinematicCharacterController": () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_5__.KinematicCharacterController),
/* harmony export */   "MassPropsMode": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),
/* harmony export */   "MotorModel": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MotorModel),
/* harmony export */   "MultibodyJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint),
/* harmony export */   "MultibodyJointSet": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJointSet),
/* harmony export */   "NarrowPhase": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.NarrowPhase),
/* harmony export */   "PhysicsPipeline": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.PhysicsPipeline),
/* harmony export */   "PointColliderProjection": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection),
/* harmony export */   "PointProjection": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointProjection),
/* harmony export */   "Polyline": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Polyline),
/* harmony export */   "PrismaticImpulseJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticImpulseJoint),
/* harmony export */   "PrismaticMultibodyJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticMultibodyJoint),
/* harmony export */   "Quaternion": () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.Quaternion),
/* harmony export */   "QueryFilterFlags": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryFilterFlags),
/* harmony export */   "QueryPipeline": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryPipeline),
/* harmony export */   "Ray": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ray),
/* harmony export */   "RayColliderIntersection": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderIntersection),
/* harmony export */   "RayColliderToi": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderToi),
/* harmony export */   "RayIntersection": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayIntersection),
/* harmony export */   "RevoluteImpulseJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteImpulseJoint),
/* harmony export */   "RevoluteMultibodyJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteMultibodyJoint),
/* harmony export */   "RigidBody": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBody),
/* harmony export */   "RigidBodyDesc": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyDesc),
/* harmony export */   "RigidBodySet": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodySet),
/* harmony export */   "RigidBodyType": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyType),
/* harmony export */   "RotationOps": () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps),
/* harmony export */   "RoundCone": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundCone),
/* harmony export */   "RoundConvexPolyhedron": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundConvexPolyhedron),
/* harmony export */   "RoundCuboid": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundCuboid),
/* harmony export */   "RoundCylinder": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundCylinder),
/* harmony export */   "RoundTriangle": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundTriangle),
/* harmony export */   "Segment": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Segment),
/* harmony export */   "SerializationPipeline": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SerializationPipeline),
/* harmony export */   "Shape": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Shape),
/* harmony export */   "ShapeColliderTOI": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeColliderTOI),
/* harmony export */   "ShapeContact": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeContact),
/* harmony export */   "ShapeTOI": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeTOI),
/* harmony export */   "ShapeType": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeType),
/* harmony export */   "SolverFlags": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),
/* harmony export */   "SphericalImpulseJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.SphericalImpulseJoint),
/* harmony export */   "SphericalMultibodyJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.SphericalMultibodyJoint),
/* harmony export */   "TempContactForceEvent": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.TempContactForceEvent),
/* harmony export */   "TempContactManifold": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TempContactManifold),
/* harmony export */   "TriMesh": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TriMesh),
/* harmony export */   "Triangle": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Triangle),
/* harmony export */   "UnitImpulseJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitImpulseJoint),
/* harmony export */   "UnitMultibodyJoint": () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitMultibodyJoint),
/* harmony export */   "Vector3": () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.Vector3),
/* harmony export */   "VectorOps": () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps),
/* harmony export */   "World": () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.World),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dynamics */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/index.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/index.js");
/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/index.js");
/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/control/index.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_5__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);

function version() {
    return (0,_raw__WEBPACK_IMPORTED_MODULE_0__.version)();
}






//# sourceMappingURL=exports.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/broad_phase.js":
/*!************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/broad_phase.js ***!
  \************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BroadPhase": () => (/* binding */ BroadPhase)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);
_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

/**
 * The broad-phase used for coarse collision-detection.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`
 * once you are done using it.
 */
class BroadPhase {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase();
    }
    /**
     * Release the WASM memory occupied by this broad-phase.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
}
//# sourceMappingURL=broad_phase.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/collider_set.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/collider_set.js ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColliderSet": () => (/* binding */ ColliderSet)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/coarena.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collider */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/collider.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _collider__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _collider__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);




/**
 * A set of rigid bodies that can be handled by a physics pipeline.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`
 * once you are done using it (and all the rigid-bodies it created).
 */
class ColliderSet {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet();
        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();
        // Initialize the map with the existing elements, if any.
        if (raw) {
            raw.forEachColliderHandle((handle) => {
                this.map.set(handle, new _collider__WEBPACK_IMPORTED_MODULE_2__.Collider(this, handle, null));
            });
        }
    }
    /**
     * Release the WASM memory occupied by this collider set.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
        if (!!this.map) {
            this.map.clear();
        }
        this.map = undefined;
    }
    /** @internal */
    castClosure(f) {
        return (handle) => {
            if (!!f) {
                return f(this.get(handle));
            }
            else {
                return undefined;
            }
        };
    }
    /** @internal */
    finalizeDeserialization(bodies) {
        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));
    }
    /**
     * Creates a new collider and return its integer handle.
     *
     * @param bodies - The set of bodies where the collider's parent can be found.
     * @param desc - The collider's description.
     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.
     */
    createCollider(bodies, desc, parentHandle) {
        let hasParent = parentHandle != undefined && parentHandle != null;
        if (hasParent && isNaN(parentHandle))
            throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
        let rawShape = desc.shape.intoRaw();
        let rawTra = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.translation);
        let rawRot = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.rotation);
        let rawCom = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.centerOfMass);
        // #if DIM3
        let rawPrincipalInertia = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.principalAngularInertia);
        let rawInertiaFrame = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.angularInertiaLocalFrame);
        // #endif
        let handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom, 
        // #if DIM3
        rawPrincipalInertia, rawInertiaFrame, 
        // #endif
        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, hasParent, hasParent ? parentHandle : 0, bodies.raw);
        rawShape.free();
        rawTra.free();
        rawRot.free();
        rawCom.free();
        // #if DIM3
        rawPrincipalInertia.free();
        rawInertiaFrame.free();
        // #endif
        let parent = hasParent ? bodies.get(parentHandle) : null;
        let collider = new _collider__WEBPACK_IMPORTED_MODULE_2__.Collider(this, handle, parent, desc.shape);
        this.map.set(handle, collider);
        return collider;
    }
    /**
     * Remove a collider from this set.
     *
     * @param handle - The integer handle of the collider to remove.
     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.
     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.
     */
    remove(handle, islands, bodies, wakeUp) {
        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);
        this.unmap(handle);
    }
    /**
     * Internal function, do not call directly.
     * @param handle
     */
    unmap(handle) {
        this.map.delete(handle);
    }
    /**
     * Gets the rigid-body with the given handle.
     *
     * @param handle - The handle of the rigid-body to retrieve.
     */
    get(handle) {
        return this.map.get(handle);
    }
    /**
     * The number of colliders on this set.
     */
    len() {
        return this.map.len();
    }
    /**
     * Does this set contain a collider with the given handle?
     *
     * @param handle - The collider handle to check.
     */
    contains(handle) {
        return this.get(handle) != null;
    }
    /**
     * Applies the given closure to each collider contained by this set.
     *
     * @param f - The closure to apply.
     */
    forEach(f) {
        this.map.forEach(f);
    }
    /**
     * Gets all colliders in the list.
     *
     * @returns collider list.
     */
    getAll() {
        return this.map.getAll();
    }
}
//# sourceMappingURL=collider_set.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/index.js ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveCollisionTypes": () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),
/* harmony export */   "Ball": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Ball),
/* harmony export */   "BroadPhase": () => (/* reexport safe */ _broad_phase__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),
/* harmony export */   "Capsule": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Capsule),
/* harmony export */   "Collider": () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.Collider),
/* harmony export */   "ColliderDesc": () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),
/* harmony export */   "ColliderSet": () => (/* reexport safe */ _collider_set__WEBPACK_IMPORTED_MODULE_4__.ColliderSet),
/* harmony export */   "Cone": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Cone),
/* harmony export */   "ConvexPolyhedron": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ConvexPolyhedron),
/* harmony export */   "Cuboid": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Cuboid),
/* harmony export */   "Cylinder": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Cylinder),
/* harmony export */   "FeatureType": () => (/* reexport safe */ _feature__WEBPACK_IMPORTED_MODULE_5__.FeatureType),
/* harmony export */   "HalfSpace": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.HalfSpace),
/* harmony export */   "Heightfield": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Heightfield),
/* harmony export */   "MassPropsMode": () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),
/* harmony export */   "NarrowPhase": () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.NarrowPhase),
/* harmony export */   "PointColliderProjection": () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointColliderProjection),
/* harmony export */   "PointProjection": () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointProjection),
/* harmony export */   "Polyline": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Polyline),
/* harmony export */   "Ray": () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.Ray),
/* harmony export */   "RayColliderIntersection": () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderIntersection),
/* harmony export */   "RayColliderToi": () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderToi),
/* harmony export */   "RayIntersection": () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayIntersection),
/* harmony export */   "RoundCone": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundCone),
/* harmony export */   "RoundConvexPolyhedron": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundConvexPolyhedron),
/* harmony export */   "RoundCuboid": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundCuboid),
/* harmony export */   "RoundCylinder": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundCylinder),
/* harmony export */   "RoundTriangle": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundTriangle),
/* harmony export */   "Segment": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Segment),
/* harmony export */   "Shape": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Shape),
/* harmony export */   "ShapeColliderTOI": () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ShapeColliderTOI),
/* harmony export */   "ShapeContact": () => (/* reexport safe */ _contact__WEBPACK_IMPORTED_MODULE_9__.ShapeContact),
/* harmony export */   "ShapeTOI": () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ShapeTOI),
/* harmony export */   "ShapeType": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ShapeType),
/* harmony export */   "TempContactManifold": () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.TempContactManifold),
/* harmony export */   "TriMesh": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.TriMesh),
/* harmony export */   "Triangle": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Triangle)
/* harmony export */ });
/* harmony import */ var _broad_phase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broad_phase */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/broad_phase.js");
/* harmony import */ var _narrow_phase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./narrow_phase */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/narrow_phase.js");
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shape */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/shape.js");
/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./collider */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/collider.js");
/* harmony import */ var _collider_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collider_set */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/collider_set.js");
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/feature.js");
/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ray */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/ray.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/point.js");
/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toi */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/toi.js");
/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./contact */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/contact.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__]);
([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);











//# sourceMappingURL=index.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/narrow_phase.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/narrow_phase.js ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NarrowPhase": () => (/* binding */ NarrowPhase),
/* harmony export */   "TempContactManifold": () => (/* binding */ TempContactManifold)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);


/**
 * The narrow-phase used for precise collision-detection.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`
 * once you are done using it.
 */
class NarrowPhase {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase();
        this.tempManifold = new TempContactManifold(null);
    }
    /**
     * Release the WASM memory occupied by this narrow-phase.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    /**
     * Enumerates all the colliders potentially in contact with the given collider.
     *
     * @param collider1 - The second collider involved in the contact.
     * @param f - Closure that will be called on each collider that is in contact with `collider1`.
     */
    contactsWith(collider1, f) {
        this.raw.contacts_with(collider1, f);
    }
    /**
     * Enumerates all the colliders intersecting the given colliders, assuming one of them
     * is a sensor.
     */
    intersectionsWith(collider1, f) {
        this.raw.intersections_with(collider1, f);
    }
    /**
     * Iterates through all the contact manifolds between the given pair of colliders.
     *
     * @param collider1 - The first collider involved in the contact.
     * @param collider2 - The second collider involved in the contact.
     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument
     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`
     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.
     */
    contactPair(collider1, collider2, f) {
        const rawPair = this.raw.contact_pair(collider1, collider2);
        if (!!rawPair) {
            const flipped = rawPair.collider1() != collider1;
            let i;
            for (i = 0; i < rawPair.numContactManifolds(); ++i) {
                this.tempManifold.raw = rawPair.contactManifold(i);
                if (!!this.tempManifold.raw) {
                    f(this.tempManifold, flipped);
                }
                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated
                //         at the next timestep. So we must be sure to free the pair here
                //         to avoid unsoundness in the Rust code.
                this.tempManifold.free();
            }
            rawPair.free();
        }
    }
    /**
     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.
     * @param collider1 − The first collider involved in the intersection.
     * @param collider2 − The second collider involved in the intersection.
     */
    intersectionPair(collider1, collider2) {
        return this.raw.intersection_pair(collider1, collider2);
    }
}
class TempContactManifold {
    constructor(raw) {
        this.raw = raw;
    }
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    normal() {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.normal());
    }
    localNormal1() {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n1());
    }
    localNormal2() {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n2());
    }
    subshape1() {
        return this.raw.subshape1();
    }
    subshape2() {
        return this.raw.subshape2();
    }
    numContacts() {
        return this.raw.num_contacts();
    }
    localContactPoint1(i) {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p1(i));
    }
    localContactPoint2(i) {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p2(i));
    }
    contactDist(i) {
        return this.raw.contact_dist(i);
    }
    contactFid1(i) {
        return this.raw.contact_fid1(i);
    }
    contactFid2(i) {
        return this.raw.contact_fid2(i);
    }
    contactImpulse(i) {
        return this.raw.contact_impulse(i);
    }
    // #if DIM3
    contactTangentImpulseX(i) {
        return this.raw.contact_tangent_impulse_x(i);
    }
    contactTangentImpulseY(i) {
        return this.raw.contact_tangent_impulse_y(i);
    }
    // #endif
    numSolverContacts() {
        return this.raw.num_solver_contacts();
    }
    solverContactPoint(i) {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_point(i));
    }
    solverContactDist(i) {
        return this.raw.solver_contact_dist(i);
    }
    solverContactFriction(i) {
        return this.raw.solver_contact_friction(i);
    }
    solverContactRestitution(i) {
        return this.raw.solver_contact_restitution(i);
    }
    solverContactTangentVelocity(i) {
        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));
    }
}
//# sourceMappingURL=narrow_phase.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js ***!
  \**********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugRenderBuffers": () => (/* binding */ DebugRenderBuffers),
/* harmony export */   "DebugRenderPipeline": () => (/* binding */ DebugRenderPipeline)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);
_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

/**
 * The vertex and color buffers for debug-redering the physics scene.
 */
class DebugRenderBuffers {
    constructor(vertices, colors) {
        this.vertices = vertices;
        this.colors = colors;
    }
}
/**
 * A pipeline for rendering the physics scene.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`
 * once you are done using it (and all the rigid-bodies it created).
 */
class DebugRenderPipeline {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline();
    }
    /**
     * Release the WASM memory occupied by this serialization pipeline.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
        this.vertices = undefined;
        this.colors = undefined;
    }
    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {
        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);
        this.vertices = this.raw.vertices();
        this.colors = this.raw.colors();
    }
}
//# sourceMappingURL=debug_render_pipeline.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/event_queue.js":
/*!************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/event_queue.js ***!
  \************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveEvents": () => (/* binding */ ActiveEvents),
/* harmony export */   "EventQueue": () => (/* binding */ EventQueue),
/* harmony export */   "TempContactForceEvent": () => (/* binding */ TempContactForceEvent)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__]);
([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);


/**
 * Flags indicating what events are enabled for colliders.
 */
var ActiveEvents;
(function (ActiveEvents) {
    /**
     * Enable collision events.
     */
    ActiveEvents[ActiveEvents["COLLISION_EVENTS"] = 1] = "COLLISION_EVENTS";
    /**
     * Enable contact force events.
     */
    ActiveEvents[ActiveEvents["CONTACT_FORCE_EVENTS"] = 2] = "CONTACT_FORCE_EVENTS";
})(ActiveEvents || (ActiveEvents = {}));
/**
 * Event occurring when the sum of the magnitudes of the
 * contact forces between two colliders exceed a threshold.
 *
 * This object should **not** be stored anywhere. Its properties can only be
 * read from within the closure given to `EventHandler.drainContactForceEvents`.
 */
class TempContactForceEvent {
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    /**
     * The first collider involved in the contact.
     */
    collider1() {
        return this.raw.collider1();
    }
    /**
     * The second collider involved in the contact.
     */
    collider2() {
        return this.raw.collider2();
    }
    /**
     * The sum of all the forces between the two colliders.
     */
    totalForce() {
        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.raw.total_force());
    }
    /**
     * The sum of the magnitudes of each force between the two colliders.
     *
     * Note that this is **not** the same as the magnitude of `self.total_force`.
     * Here we are summing the magnitude of all the forces, instead of taking
     * the magnitude of their sum.
     */
    totalForceMagnitude() {
        return this.raw.total_force_magnitude();
    }
    /**
     * The world-space (unit) direction of the force with strongest magnitude.
     */
    maxForceDirection() {
        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.raw.max_force_direction());
    }
    /**
     * The magnitude of the largest force at a contact point of this contact pair.
     */
    maxForceMagnitude() {
        return this.raw.max_force_magnitude();
    }
}
/**
 * A structure responsible for collecting events generated
 * by the physics engine.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`
 * once you are done using it.
 */
class EventQueue {
    /**
     * Creates a new event collector.
     *
     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will
     * be automatically drained before each `world.step(collector)`. If false, the collector will
     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of
     * RAM if no drain is performed.
     */
    constructor(autoDrain, raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_1__.RawEventQueue(autoDrain);
    }
    /**
     * Release the WASM memory occupied by this event-queue.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    /**
     * Applies the given javascript closure on each collision event of this collector, then clear
     * the internal collision event buffer.
     *
     * @param f - JavaScript closure applied to each collision event. The
     * closure must take three arguments: two integers representing the handles of the colliders
     * involved in the collision, and a boolean indicating if the collision started (true) or stopped
     * (false).
     */
    drainCollisionEvents(f) {
        this.raw.drainCollisionEvents(f);
    }
    /**
     * Applies the given javascript closure on each contact force event of this collector, then clear
     * the internal collision event buffer.
     *
     * @param f - JavaScript closure applied to each collision event. The
     *            closure must take one `TempContactForceEvent` argument.
     */
    drainContactForceEvents(f) {
        let event = new TempContactForceEvent();
        this.raw.drainContactForceEvents((raw) => {
            event.raw = raw;
            f(event);
            event.free();
        });
    }
    /**
     * Removes all events contained by this collector
     */
    clear() {
        this.raw.clear();
    }
}
//# sourceMappingURL=event_queue.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/index.js ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveEvents": () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.ActiveEvents),
/* harmony export */   "ActiveHooks": () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),
/* harmony export */   "DebugRenderBuffers": () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderBuffers),
/* harmony export */   "DebugRenderPipeline": () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderPipeline),
/* harmony export */   "EventQueue": () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.EventQueue),
/* harmony export */   "PhysicsPipeline": () => (/* reexport safe */ _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__.PhysicsPipeline),
/* harmony export */   "QueryFilterFlags": () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryFilterFlags),
/* harmony export */   "QueryPipeline": () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryPipeline),
/* harmony export */   "SerializationPipeline": () => (/* reexport safe */ _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__.SerializationPipeline),
/* harmony export */   "SolverFlags": () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),
/* harmony export */   "TempContactForceEvent": () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.TempContactForceEvent),
/* harmony export */   "World": () => (/* reexport safe */ _world__WEBPACK_IMPORTED_MODULE_0__.World)
/* harmony export */ });
/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/world.js");
/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./physics_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js");
/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serialization_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js");
/* harmony import */ var _event_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./event_queue */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/event_queue.js");
/* harmony import */ var _physics_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./physics_hooks */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/physics_hooks.js");
/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug_render_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js");
/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./query_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__]);
([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);







//# sourceMappingURL=index.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/physics_hooks.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/physics_hooks.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveHooks": () => (/* binding */ ActiveHooks),
/* harmony export */   "SolverFlags": () => (/* binding */ SolverFlags)
/* harmony export */ });
var ActiveHooks;
(function (ActiveHooks) {
    ActiveHooks[ActiveHooks["FILTER_CONTACT_PAIRS"] = 1] = "FILTER_CONTACT_PAIRS";
    ActiveHooks[ActiveHooks["FILTER_INTERSECTION_PAIRS"] = 2] = "FILTER_INTERSECTION_PAIRS";
    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */
})(ActiveHooks || (ActiveHooks = {}));
var SolverFlags;
(function (SolverFlags) {
    SolverFlags[SolverFlags["EMPTY"] = 0] = "EMPTY";
    SolverFlags[SolverFlags["COMPUTE_IMPULSE"] = 1] = "COMPUTE_IMPULSE";
})(SolverFlags || (SolverFlags = {}));
//# sourceMappingURL=physics_hooks.js.map

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js ***!
  \*****************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhysicsPipeline": () => (/* binding */ PhysicsPipeline)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);


class PhysicsPipeline {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline();
    }
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {
        let rawG = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);
        if (!!eventQueue) {
            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);
        }
        else {
            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);
        }
        rawG.free();
    }
}
//# sourceMappingURL=physics_pipeline.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js ***!
  \***************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryFilterFlags": () => (/* binding */ QueryFilterFlags),
/* harmony export */   "QueryPipeline": () => (/* binding */ QueryPipeline)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/ray.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/point.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geometry */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/toi.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



// NOTE: must match the bits in the QueryFilterFlags on the Rust side.
/**
 * Flags for excluding whole sets of colliders from a scene query.
 */
var QueryFilterFlags;
(function (QueryFilterFlags) {
    /**
     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.
     */
    QueryFilterFlags[QueryFilterFlags["EXCLUDE_FIXED"] = 1] = "EXCLUDE_FIXED";
    /**
     * Exclude from the query any collider attached to a dynamic rigid-body.
     */
    QueryFilterFlags[QueryFilterFlags["EXCLUDE_KINEMATIC"] = 2] = "EXCLUDE_KINEMATIC";
    /**
     * Exclude from the query any collider attached to a kinematic rigid-body.
     */
    QueryFilterFlags[QueryFilterFlags["EXCLUDE_DYNAMIC"] = 4] = "EXCLUDE_DYNAMIC";
    /**
     * Exclude from the query any collider that is a sensor.
     */
    QueryFilterFlags[QueryFilterFlags["EXCLUDE_SENSORS"] = 8] = "EXCLUDE_SENSORS";
    /**
     * Exclude from the query any collider that is not a sensor.
     */
    QueryFilterFlags[QueryFilterFlags["EXCLUDE_SOLIDS"] = 16] = "EXCLUDE_SOLIDS";
    /**
     * Excludes all colliders not attached to a dynamic rigid-body.
     */
    QueryFilterFlags[QueryFilterFlags["ONLY_DYNAMIC"] = 3] = "ONLY_DYNAMIC";
    /**
     * Excludes all colliders not attached to a kinematic rigid-body.
     */
    QueryFilterFlags[QueryFilterFlags["ONLY_KINEMATIC"] = 5] = "ONLY_KINEMATIC";
    /**
     * Exclude all colliders attached to a non-fixed rigid-body
     * (this will not exclude colliders not attached to any rigid-body).
     */
    QueryFilterFlags[QueryFilterFlags["ONLY_FIXED"] = 6] = "ONLY_FIXED";
})(QueryFilterFlags || (QueryFilterFlags = {}));
/**
 * A pipeline for performing queries on all the colliders of a scene.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`
 * once you are done using it (and all the rigid-bodies it created).
 */
class QueryPipeline {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline();
    }
    /**
     * Release the WASM memory occupied by this query pipeline.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    /**
     * Updates the acceleration structure of the query pipeline.
     * @param bodies - The set of rigid-bodies taking part in this pipeline.
     * @param colliders - The set of colliders taking part in this pipeline.
     */
    update(bodies, colliders) {
        this.raw.update(bodies.raw, colliders.raw);
    }
    /**
     * Find the closest intersection between a ray and a set of collider.
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param ray - The ray to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the length of the ray to `ray.dir.norm() * maxToi`.
     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
     *   whereas `false` implies that all shapes are hollow for this ray-cast.
     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
     * @param filter - The callback to filter out which collider will be hit.
     */
    castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);
        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);
        let result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderToi.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));
        rawOrig.free();
        rawDir.free();
        return result;
    }
    /**
     * Find the closest intersection between a ray and a set of collider.
     *
     * This also computes the normal at the hit point.
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param ray - The ray to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the length of the ray to `ray.dir.norm() * maxToi`.
     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
     *   whereas `false` implies that all shapes are hollow for this ray-cast.
     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
     */
    castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);
        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);
        let result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));
        rawOrig.free();
        rawDir.free();
        return result;
    }
    /**
     * Cast a ray and collects all the intersections between a ray and the scene.
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param ray - The ray to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the length of the ray to `ray.dir.norm() * maxToi`.
     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
     *   whereas `false` implies that all shapes are hollow for this ray-cast.
     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.
     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.
     */
    intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);
        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);
        let rawCallback = (rawInter) => {
            return callback(_geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, rawInter));
        };
        this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);
        rawOrig.free();
        rawDir.free();
    }
    /**
     * Gets the handle of up to one collider intersecting the given shape.
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param shapePos - The position of the shape used for the intersection test.
     * @param shapeRot - The orientation of the shape used for the intersection test.
     * @param shape - The shape used for the intersection test.
     * @param groups - The bit groups and filter associated to the ray, in order to only
     *   hit the colliders with collision groups compatible with the ray's group.
     */
    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);
        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);
        let rawShape = shape.intoRaw();
        let result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);
        rawPos.free();
        rawRot.free();
        rawShape.free();
        return result;
    }
    /**
     * Find the projection of a point on the closest collider.
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param point - The point to project.
     * @param solid - If this is set to `true` then the collider shapes are considered to
     *   be plain (if the point is located inside of a plain shape, its projection is the point
     *   itself). If it is set to `false` the collider shapes are considered to be hollow
     *   (if the point is located inside of an hollow shape, it is projected on the shape's
     *   boundary).
     * @param groups - The bit groups and filter associated to the point to project, in order to only
     *   project on colliders with collision groups compatible with the ray's group.
     */
    projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);
        let result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));
        rawPoint.free();
        return result;
    }
    /**
     * Find the projection of a point on the closest collider.
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param point - The point to project.
     * @param groups - The bit groups and filter associated to the point to project, in order to only
     *   project on colliders with collision groups compatible with the ray's group.
     */
    projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);
        let result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));
        rawPoint.free();
        return result;
    }
    /**
     * Find all the colliders containing the given point.
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param point - The point used for the containment test.
     * @param groups - The bit groups and filter associated to the point to test, in order to only
     *   test on colliders with collision groups compatible with the ray's group.
     * @param callback - A function called with the handles of each collider with a shape
     *   containing the `point`.
     */
    intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);
        this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);
        rawPoint.free();
    }
    /**
     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.
     * This is similar to ray-casting except that we are casting a whole shape instead of
     * just a point (the ray origin).
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param shapePos - The initial position of the shape to cast.
     * @param shapeRot - The initial rotation of the shape to cast.
     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).
     * @param shape - The shape to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.
     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if
     *   the shape is penetrating another shape at its starting point **and** its trajectory is such
     *   that it’s on a path to exist that penetration state.
     * @param groups - The bit groups and filter associated to the shape to cast, in order to only
     *   test on colliders with collision groups compatible with this group.
     */
    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);
        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);
        let rawVel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapeVel);
        let rawShape = shape.intoRaw();
        let result = _geometry__WEBPACK_IMPORTED_MODULE_4__.ShapeColliderTOI.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));
        rawPos.free();
        rawRot.free();
        rawVel.free();
        rawShape.free();
        return result;
    }
    /**
     * Retrieve all the colliders intersecting the given shape.
     *
     * @param colliders - The set of colliders taking part in this pipeline.
     * @param shapePos - The position of the shape to test.
     * @param shapeRot - The orientation of the shape to test.
     * @param shape - The shape to test.
     * @param groups - The bit groups and filter associated to the shape to test, in order to only
     *   test on colliders with collision groups compatible with this group.
     * @param callback - A function called with the handles of each collider intersecting the `shape`.
     */
    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);
        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);
        let rawShape = shape.intoRaw();
        this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);
        rawPos.free();
        rawRot.free();
        rawShape.free();
    }
    /**
     * Finds the handles of all the colliders with an AABB intersecting the given AABB.
     *
     * @param aabbCenter - The center of the AABB to test.
     * @param aabbHalfExtents - The half-extents of the AABB to test.
     * @param callback - The callback that will be called with the handles of all the colliders
     *                   currently intersecting the given AABB.
     */
    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {
        let rawCenter = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbCenter);
        let rawHalfExtents = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbHalfExtents);
        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);
        rawCenter.free();
        rawHalfExtents.free();
    }
}
//# sourceMappingURL=query_pipeline.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js ***!
  \***********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SerializationPipeline": () => (/* binding */ SerializationPipeline)
/* harmony export */ });
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./world */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/world.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__]);
([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



/**
 * A pipeline for serializing the physics scene.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`
 * once you are done using it (and all the rigid-bodies it created).
 */
class SerializationPipeline {
    constructor(raw) {
        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline();
    }
    /**
     * Release the WASM memory occupied by this serialization pipeline.
     */
    free() {
        if (!!this.raw) {
            this.raw.free();
        }
        this.raw = undefined;
    }
    /**
     * Serialize a complete physics state into a single byte array.
     * @param gravity - The current gravity affecting the simulation.
     * @param integrationParameters - The integration parameters of the simulation.
     * @param broadPhase - The broad-phase of the simulation.
     * @param narrowPhase - The narrow-phase of the simulation.
     * @param bodies - The rigid-bodies taking part into the simulation.
     * @param colliders - The colliders taking part into the simulation.
     * @param impulseJoints - The impulse joints taking part into the simulation.
     * @param multibodyJoints - The multibody joints taking part into the simulation.
     */
    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {
        let rawGra = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);
        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);
        rawGra.free();
        return res;
    }
    /**
     * Deserialize the complete physics state from a single byte array.
     *
     * @param data - The byte array to deserialize.
     */
    deserializeAll(data) {
        return _world__WEBPACK_IMPORTED_MODULE_2__.World.fromRaw(this.raw.deserializeAll(data));
    }
}
//# sourceMappingURL=serialization_pipeline.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/world.js":
/*!******************************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/world.js ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "World": () => (/* binding */ World)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/broad_phase.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/narrow_phase.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geometry */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/geometry/collider_set.js");
/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dynamics */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js");
/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dynamics */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/island_manager.js");
/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dynamics */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js");
/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamics */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js");
/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../dynamics */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js");
/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamics */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../math */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/math.js");
/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./physics_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js");
/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./query_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js");
/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./serialization_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js");
/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./debug_render_pipeline */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js");
/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../control */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/control/character_controller.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_dynamics__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _dynamics__WEBPACK_IMPORTED_MODULE_4__, _geometry__WEBPACK_IMPORTED_MODULE_5__, _dynamics__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _query_pipeline__WEBPACK_IMPORTED_MODULE_9__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__, _math__WEBPACK_IMPORTED_MODULE_13__, _control__WEBPACK_IMPORTED_MODULE_14__]);
([_dynamics__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _dynamics__WEBPACK_IMPORTED_MODULE_4__, _geometry__WEBPACK_IMPORTED_MODULE_5__, _dynamics__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _query_pipeline__WEBPACK_IMPORTED_MODULE_9__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__, _math__WEBPACK_IMPORTED_MODULE_13__, _control__WEBPACK_IMPORTED_MODULE_14__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);








/**
 * The physics world.
 *
 * This contains all the data-structures necessary for creating and simulating
 * bodies with contacts, joints, and external forces.
 */
class World {
    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {
        this.gravity = gravity;
        this.integrationParameters = new _dynamics__WEBPACK_IMPORTED_MODULE_0__.IntegrationParameters(rawIntegrationParameters);
        this.islands = new _dynamics__WEBPACK_IMPORTED_MODULE_1__.IslandManager(rawIslands);
        this.broadPhase = new _geometry__WEBPACK_IMPORTED_MODULE_2__.BroadPhase(rawBroadPhase);
        this.narrowPhase = new _geometry__WEBPACK_IMPORTED_MODULE_3__.NarrowPhase(rawNarrowPhase);
        this.bodies = new _dynamics__WEBPACK_IMPORTED_MODULE_4__.RigidBodySet(rawBodies);
        this.colliders = new _geometry__WEBPACK_IMPORTED_MODULE_5__.ColliderSet(rawColliders);
        this.impulseJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_6__.ImpulseJointSet(rawImpulseJoints);
        this.multibodyJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_7__.MultibodyJointSet(rawMultibodyJoints);
        this.ccdSolver = new _dynamics__WEBPACK_IMPORTED_MODULE_8__.CCDSolver(rawCCDSolver);
        this.queryPipeline = new _query_pipeline__WEBPACK_IMPORTED_MODULE_9__.QueryPipeline(rawQueryPipeline);
        this.physicsPipeline = new _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__.PhysicsPipeline(rawPhysicsPipeline);
        this.serializationPipeline = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__.SerializationPipeline(rawSerializationPipeline);
        this.debugRenderPipeline = new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__.DebugRenderPipeline(rawDebugRenderPipeline);
        this.characterControllers = new Set();
        this.impulseJoints.finalizeDeserialization(this.bodies);
        this.bodies.finalizeDeserialization(this.colliders);
        this.colliders.finalizeDeserialization(this.bodies);
    }
    /**
     * Release the WASM memory occupied by this physics world.
     *
     * All the fields of this physics world will be freed as well,
     * so there is no need to call their `.free()` methods individually.
     */
    free() {
        this.integrationParameters.free();
        this.islands.free();
        this.broadPhase.free();
        this.narrowPhase.free();
        this.bodies.free();
        this.colliders.free();
        this.impulseJoints.free();
        this.multibodyJoints.free();
        this.ccdSolver.free();
        this.queryPipeline.free();
        this.physicsPipeline.free();
        this.serializationPipeline.free();
        this.debugRenderPipeline.free();
        this.characterControllers.forEach((controller) => controller.free());
        this.integrationParameters = undefined;
        this.islands = undefined;
        this.broadPhase = undefined;
        this.narrowPhase = undefined;
        this.bodies = undefined;
        this.colliders = undefined;
        this.ccdSolver = undefined;
        this.impulseJoints = undefined;
        this.multibodyJoints = undefined;
        this.queryPipeline = undefined;
        this.physicsPipeline = undefined;
        this.serializationPipeline = undefined;
        this.debugRenderPipeline = undefined;
        this.characterControllers = undefined;
    }
    static fromRaw(raw) {
        if (!raw)
            return null;
        return new World(_math__WEBPACK_IMPORTED_MODULE_13__.VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());
    }
    /**
     * Takes a snapshot of this world.
     *
     * Use `World.restoreSnapshot` to create a new physics world with a state identical to
     * the state when `.takeSnapshot()` is called.
     */
    takeSnapshot() {
        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);
    }
    /**
     * Creates a new physics world from a snapshot.
     *
     * This new physics world will be an identical copy of the snapshoted physics world.
     */
    static restoreSnapshot(data) {
        let deser = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__.SerializationPipeline();
        return deser.deserializeAll(data);
    }
    /**
     * Computes all the lines (and their colors) needed to render the scene.
     */
    debugRender() {
        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);
        return new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__.DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);
    }
    /**
     * Advance the simulation by one time step.
     *
     * All events generated by the physics engine are ignored.
     *
     * @param EventQueue - (optional) structure responsible for collecting
     *   events generated by the physics engine.
     */
    step(eventQueue, hooks) {
        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);
        this.queryPipeline.update(this.bodies, this.colliders);
    }
    /**
     * Update colliders positions after rigid-bodies moved.
     *
     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is
     * generally automatically done at the beginning and the end of each simulation step with World.step.
     * If the positions need to be updated without running a simulation step this method can be called manually.
     */
    propagateModifiedBodyPositionsToColliders() {
        this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);
    }
    /**
     * Ensure subsequent scene queries take into account the collider positions set before this method is called.
     *
     * This does not step the physics simulation forward.
     */
    updateSceneQueries() {
        this.propagateModifiedBodyPositionsToColliders();
        this.queryPipeline.update(this.bodies, this.colliders);
    }
    /**
     * The current simulation timestep.
     */
    get timestep() {
        return this.integrationParameters.dt;
    }
    /**
     * Sets the new simulation timestep.
     *
     * The simulation timestep governs by how much the physics state of the world will
     * be integrated. A simulation timestep should:
     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,
     * corresponds to the time between two frames of a game running at 60FPS).
     * - not vary too much during the course of the simulation. A timestep with large variations may
     * cause instabilities in the simulation.
     *
     * @param dt - The timestep length, in seconds.
     */
    set timestep(dt) {
        this.integrationParameters.dt = dt;
    }
    /**
     * The maximum velocity iterations the velocity-based force constraint solver can make.
     */
    get maxVelocityIterations() {
        return this.integrationParameters.maxVelocityIterations;
    }
    /**
     * Sets the maximum number of velocity iterations (default: 4).
     *
     * The greater this value is, the most rigid and realistic the physics simulation will be.
     * However a greater number of iterations is more computationally intensive.
     *
     * @param niter - The new maximum number of velocity iterations.
     */
    set maxVelocityIterations(niter) {
        this.integrationParameters.maxVelocityIterations = niter;
    }
    /**
     * The maximum velocity iterations the velocity-based friction constraint solver can make.
     */
    get maxVelocityFrictionIterations() {
        return this.integrationParameters.maxVelocityFrictionIterations;
    }
    /**
     * Sets the maximum number of velocity iterations for friction (default: 8).
     *
     * The greater this value is, the most realistic friction will be.
     * However a greater number of iterations is more computationally intensive.
     *
     * @param niter - The new maximum number of velocity iterations.
     */
    set maxVelocityFrictionIterations(niter) {
        this.integrationParameters.maxVelocityFrictionIterations = niter;
    }
    /**
     * The maximum velocity iterations the velocity-based constraint solver can make to attempt to remove
     * the energy introduced by constraint stabilization.
     */
    get maxStabilizationIterations() {
        return this.integrationParameters.maxStabilizationIterations;
    }
    /**
     * Sets the maximum number of velocity iterations for stabilization (default: 1).
     *
     * @param niter - The new maximum number of velocity iterations.
     */
    set maxStabilizationIterations(niter) {
        this.integrationParameters.maxStabilizationIterations = niter;
    }
    /**
     * Creates a new rigid-body from the given rigd-body descriptior.
     *
     * @param body - The description of the rigid-body to create.
     */
    createRigidBody(body) {
        return this.bodies.createRigidBody(this.colliders, body);
    }
    /**
     * Creates a new character controller.
     *
     * @param offset - The artificial gap added between the character’s chape and its environment.
     */
    createCharacterController(offset) {
        let controller = new _control__WEBPACK_IMPORTED_MODULE_14__.KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);
        this.characterControllers.add(controller);
        return controller;
    }
    /**
     * Removes a character controller from this world.
     *
     * @param controller - The character controller to remove.
     */
    removeCharacterController(controller) {
        this.characterControllers.delete(controller);
        controller.free();
    }
    /**
     * Creates a new collider.
     *
     * @param desc - The description of the collider.
     * @param parent - The rigid-body this collider is attached to.
     */
    createCollider(desc, parent) {
        let parentHandle = parent ? parent.handle : undefined;
        return this.colliders.createCollider(this.bodies, desc, parentHandle);
    }
    /**
     * Creates a new impulse joint from the given joint descriptor.
     *
     * @param params - The description of the joint to create.
     * @param parent1 - The first rigid-body attached to this joint.
     * @param parent2 - The second rigid-body attached to this joint.
     * @param wakeUp - Should the attached rigid-bodies be awakened?
     */
    createImpulseJoint(params, parent1, parent2, wakeUp) {
        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);
    }
    /**
     * Creates a new multibody joint from the given joint descriptor.
     *
     * @param params - The description of the joint to create.
     * @param parent1 - The first rigid-body attached to this joint.
     * @param parent2 - The second rigid-body attached to this joint.
     * @param wakeUp - Should the attached rigid-bodies be awakened?
     */
    createMultibodyJoint(params, parent1, parent2, wakeUp) {
        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);
    }
    /**
     * Retrieves a rigid-body from its handle.
     *
     * @param handle - The integer handle of the rigid-body to retrieve.
     */
    getRigidBody(handle) {
        return this.bodies.get(handle);
    }
    /**
     * Retrieves a collider from its handle.
     *
     * @param handle - The integer handle of the collider to retrieve.
     */
    getCollider(handle) {
        return this.colliders.get(handle);
    }
    /**
     * Retrieves an impulse joint from its handle.
     *
     * @param handle - The integer handle of the impulse joint to retrieve.
     */
    getImpulseJoint(handle) {
        return this.impulseJoints.get(handle);
    }
    /**
     * Retrieves an multibody joint from its handle.
     *
     * @param handle - The integer handle of the multibody joint to retrieve.
     */
    getMultibodyJoint(handle) {
        return this.multibodyJoints.get(handle);
    }
    /**
     * Removes the given rigid-body from this physics world.
     *
     * This will remove this rigid-body as well as all its attached colliders and joints.
     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.
     *
     * @param body - The rigid-body to remove.
     */
    removeRigidBody(body) {
        if (this.bodies) {
            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);
        }
    }
    /**
     * Removes the given collider from this physics world.
     *
     * @param collider - The collider to remove.
     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.
     */
    removeCollider(collider, wakeUp) {
        if (this.colliders) {
            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);
        }
    }
    /**
     * Removes the given impulse joint from this physics world.
     *
     * @param joint - The impulse joint to remove.
     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.
     */
    removeImpulseJoint(joint, wakeUp) {
        if (this.impulseJoints) {
            this.impulseJoints.remove(joint.handle, wakeUp);
        }
    }
    /**
     * Removes the given multibody joint from this physics world.
     *
     * @param joint - The multibody joint to remove.
     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.
     */
    removeMultibodyJoint(joint, wakeUp) {
        if (this.impulseJoints) {
            this.multibodyJoints.remove(joint.handle, wakeUp);
        }
    }
    /**
     * Applies the given closure to each collider managed by this physics world.
     *
     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.
     */
    forEachCollider(f) {
        this.colliders.forEach(f);
    }
    /**
     * Applies the given closure to each rigid-body managed by this physics world.
     *
     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.
     */
    forEachRigidBody(f) {
        this.bodies.forEach(f);
    }
    /**
     * Applies the given closure to each active rigid-body managed by this physics world.
     *
     * After a short time of inactivity, a rigid-body is automatically deactivated ("asleep") by
     * the physics engine in order to save computational power. A sleeping rigid-body never moves
     * unless it is moved manually by the user.
     *
     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.
     */
    forEachActiveRigidBody(f) {
        this.bodies.forEachActiveRigidBody(this.islands, f);
    }
    /**
     * Find the closest intersection between a ray and the physics world.
     *
     * @param ray - The ray to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the length of the ray to `ray.dir.norm() * maxToi`.
     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
     *   whereas `false` implies that all shapes are hollow for this ray-cast.
     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
     * @param filter - The callback to filter out which collider will be hit.
     */
    castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Find the closest intersection between a ray and the physics world.
     *
     * This also computes the normal at the hit point.
     * @param ray - The ray to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the length of the ray to `ray.dir.norm() * maxToi`.
     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
     *   whereas `false` implies that all shapes are hollow for this ray-cast.
     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
     */
    castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Cast a ray and collects all the intersections between a ray and the scene.
     *
     * @param ray - The ray to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the length of the ray to `ray.dir.norm() * maxToi`.
     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
     *   whereas `false` implies that all shapes are hollow for this ray-cast.
     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.
     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.
     */
    intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Gets the handle of up to one collider intersecting the given shape.
     *
     * @param shapePos - The position of the shape used for the intersection test.
     * @param shapeRot - The orientation of the shape used for the intersection test.
     * @param shape - The shape used for the intersection test.
     * @param groups - The bit groups and filter associated to the ray, in order to only
     *   hit the colliders with collision groups compatible with the ray's group.
     */
    intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        let handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
        return handle != null ? this.colliders.get(handle) : null;
    }
    /**
     * Find the projection of a point on the closest collider.
     *
     * @param point - The point to project.
     * @param solid - If this is set to `true` then the collider shapes are considered to
     *   be plain (if the point is located inside of a plain shape, its projection is the point
     *   itself). If it is set to `false` the collider shapes are considered to be hollow
     *   (if the point is located inside of an hollow shape, it is projected on the shape's
     *   boundary).
     * @param groups - The bit groups and filter associated to the point to project, in order to only
     *   project on colliders with collision groups compatible with the ray's group.
     */
    projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Find the projection of a point on the closest collider.
     *
     * @param point - The point to project.
     * @param groups - The bit groups and filter associated to the point to project, in order to only
     *   project on colliders with collision groups compatible with the ray's group.
     */
    projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Find all the colliders containing the given point.
     *
     * @param point - The point used for the containment test.
     * @param groups - The bit groups and filter associated to the point to test, in order to only
     *   test on colliders with collision groups compatible with the ray's group.
     * @param callback - A function called with the handles of each collider with a shape
     *   containing the `point`.
     */
    intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.
     * This is similar to ray-casting except that we are casting a whole shape instead of
     * just a point (the ray origin).
     *
     * @param shapePos - The initial position of the shape to cast.
     * @param shapeRot - The initial rotation of the shape to cast.
     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).
     * @param shape - The shape to cast.
     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.
     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if
     *   the shape is penetrating another shape at its starting point **and** its trajectory is such
     *   that it’s on a path to exist that penetration state.
     * @param groups - The bit groups and filter associated to the shape to cast, in order to only
     *   test on colliders with collision groups compatible with this group.
     */
    castShape(shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Retrieve all the colliders intersecting the given shape.
     *
     * @param shapePos - The position of the shape to test.
     * @param shapeRot - The orientation of the shape to test.
     * @param shape - The shape to test.
     * @param groups - The bit groups and filter associated to the shape to test, in order to only
     *   test on colliders with collision groups compatible with this group.
     * @param callback - A function called with the handles of each collider intersecting the `shape`.
     */
    intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {
        this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));
    }
    /**
     * Finds the handles of all the colliders with an AABB intersecting the given AABB.
     *
     * @param aabbCenter - The center of the AABB to test.
     * @param aabbHalfExtents - The half-extents of the AABB to test.
     * @param callback - The callback that will be called with the handles of all the colliders
     *                   currently intersecting the given AABB.
     */
    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {
        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));
    }
    /**
     * Enumerates all the colliders potentially in contact with the given collider.
     *
     * @param collider1 - The second collider involved in the contact.
     * @param f - Closure that will be called on each collider that is in contact with `collider1`.
     */
    contactsWith(collider1, f) {
        this.narrowPhase.contactsWith(collider1.handle, this.colliders.castClosure(f));
    }
    /**
     * Enumerates all the colliders intersecting the given colliders, assuming one of them
     * is a sensor.
     */
    intersectionsWith(collider1, f) {
        this.narrowPhase.intersectionsWith(collider1.handle, this.colliders.castClosure(f));
    }
    /**
     * Iterates through all the contact manifolds between the given pair of colliders.
     *
     * @param collider1 - The first collider involved in the contact.
     * @param collider2 - The second collider involved in the contact.
     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument
     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`
     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.
     */
    contactPair(collider1, collider2, f) {
        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);
    }
    /**
     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.
     * @param collider1 − The first collider involved in the intersection.
     * @param collider2 − The second collider involved in the intersection.
     */
    intersectionPair(collider1, collider2) {
        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);
    }
}
//# sourceMappingURL=world.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier.js":
/*!**********************************************************************!*\
  !*** ./node_modules/elixr/node_modules/@dimforge/rapier3d/rapier.js ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveCollisionTypes": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveCollisionTypes),
/* harmony export */   "ActiveEvents": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents),
/* harmony export */   "ActiveHooks": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveHooks),
/* harmony export */   "Ball": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ball),
/* harmony export */   "BroadPhase": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),
/* harmony export */   "CCDSolver": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CCDSolver),
/* harmony export */   "Capsule": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Capsule),
/* harmony export */   "CharacterCollision": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),
/* harmony export */   "CoefficientCombineRule": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),
/* harmony export */   "Collider": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Collider),
/* harmony export */   "ColliderDesc": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc),
/* harmony export */   "ColliderSet": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderSet),
/* harmony export */   "Cone": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Cone),
/* harmony export */   "ConvexPolyhedron": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ConvexPolyhedron),
/* harmony export */   "Cuboid": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Cuboid),
/* harmony export */   "Cylinder": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Cylinder),
/* harmony export */   "DebugRenderBuffers": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderBuffers),
/* harmony export */   "DebugRenderPipeline": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderPipeline),
/* harmony export */   "EventQueue": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.EventQueue),
/* harmony export */   "FeatureType": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FeatureType),
/* harmony export */   "FixedImpulseJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedImpulseJoint),
/* harmony export */   "FixedMultibodyJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedMultibodyJoint),
/* harmony export */   "HalfSpace": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.HalfSpace),
/* harmony export */   "Heightfield": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Heightfield),
/* harmony export */   "ImpulseJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJoint),
/* harmony export */   "ImpulseJointSet": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJointSet),
/* harmony export */   "IntegrationParameters": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IntegrationParameters),
/* harmony export */   "IslandManager": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IslandManager),
/* harmony export */   "JointData": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointData),
/* harmony export */   "JointType": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointType),
/* harmony export */   "KinematicCharacterController": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController),
/* harmony export */   "MassPropsMode": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MassPropsMode),
/* harmony export */   "MotorModel": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MotorModel),
/* harmony export */   "MultibodyJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJoint),
/* harmony export */   "MultibodyJointSet": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJointSet),
/* harmony export */   "NarrowPhase": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.NarrowPhase),
/* harmony export */   "PhysicsPipeline": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PhysicsPipeline),
/* harmony export */   "PointColliderProjection": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointColliderProjection),
/* harmony export */   "PointProjection": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointProjection),
/* harmony export */   "Polyline": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Polyline),
/* harmony export */   "PrismaticImpulseJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticImpulseJoint),
/* harmony export */   "PrismaticMultibodyJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticMultibodyJoint),
/* harmony export */   "Quaternion": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion),
/* harmony export */   "QueryFilterFlags": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryFilterFlags),
/* harmony export */   "QueryPipeline": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryPipeline),
/* harmony export */   "Ray": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ray),
/* harmony export */   "RayColliderIntersection": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderIntersection),
/* harmony export */   "RayColliderToi": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderToi),
/* harmony export */   "RayIntersection": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayIntersection),
/* harmony export */   "RevoluteImpulseJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteImpulseJoint),
/* harmony export */   "RevoluteMultibodyJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteMultibodyJoint),
/* harmony export */   "RigidBody": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBody),
/* harmony export */   "RigidBodyDesc": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),
/* harmony export */   "RigidBodySet": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodySet),
/* harmony export */   "RigidBodyType": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),
/* harmony export */   "RotationOps": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RotationOps),
/* harmony export */   "RoundCone": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundCone),
/* harmony export */   "RoundConvexPolyhedron": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolyhedron),
/* harmony export */   "RoundCuboid": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundCuboid),
/* harmony export */   "RoundCylinder": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundCylinder),
/* harmony export */   "RoundTriangle": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundTriangle),
/* harmony export */   "Segment": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Segment),
/* harmony export */   "SerializationPipeline": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SerializationPipeline),
/* harmony export */   "Shape": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Shape),
/* harmony export */   "ShapeColliderTOI": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeColliderTOI),
/* harmony export */   "ShapeContact": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeContact),
/* harmony export */   "ShapeTOI": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeTOI),
/* harmony export */   "ShapeType": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeType),
/* harmony export */   "SolverFlags": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SolverFlags),
/* harmony export */   "SphericalImpulseJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SphericalImpulseJoint),
/* harmony export */   "SphericalMultibodyJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SphericalMultibodyJoint),
/* harmony export */   "TempContactForceEvent": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactForceEvent),
/* harmony export */   "TempContactManifold": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactManifold),
/* harmony export */   "TriMesh": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TriMesh),
/* harmony export */   "Triangle": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Triangle),
/* harmony export */   "UnitImpulseJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitImpulseJoint),
/* harmony export */   "UnitMultibodyJoint": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitMultibodyJoint),
/* harmony export */   "Vector3": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Vector3),
/* harmony export */   "VectorOps": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.VectorOps),
/* harmony export */   "World": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.World),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "version": () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.version)
/* harmony export */ });
/* harmony import */ var _exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exports */ "./node_modules/elixr/node_modules/@dimforge/rapier3d/exports.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_exports__WEBPACK_IMPORTED_MODULE_0__]);
_exports__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_exports__WEBPACK_IMPORTED_MODULE_0__);
//# sourceMappingURL=rapier.js.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_elixr_node_modules_dimforge_rapier3d_rapier_js.bundle.js.map